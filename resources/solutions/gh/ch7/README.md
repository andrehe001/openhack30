# Challenge 7

## Scan for secrets

Real secrets to find are located in two files: `iac/terraform/locals.defaults.tf` and `iac/bicep/variables.json`. The rest are false-positive and have to be suppressed/allowlisted.

> Because secrets are in Terraform and Bicep files, and your team has chosen the IaC path at the beginning of the OpenHack, it's OK to mark it as a false-positive for opposite IaC to your team's choice.

### Github Advanced Security

1. Follow the steps in [Enabling secret scanning for private repositories](https://docs.github.com/en/code-security/secret-scanning/configuring-secret-scanning-for-your-repositories)
1. Define custom pattern for secret scanning using provided example in the Hints section [Defining custom patterns for secret scanning](https://docs.github.com/en/enterprise-cloud@latest/code-security/secret-scanning/defining-custom-patterns-for-secret-scanning)
1. Follow the steps in [Manage secret alerts](https://docs.github.com/en/code-security/secret-scanning/managing-alerts-from-secret-scanning)

### Gitleaks

One of the sample solutions (`workflow.pr.api.poi.gitleaks.yml`) is using a 3rd party extension called [Gitleaks](https://github.com/zricethezav/gitleaks) to look for credentials and secrets in code.

To make the process easier, a [GitHub Action](https://github.com/marketplace/actions/gitleaks-scanner) was provided, which encapsulates the call to `gitleaks`. This is an alternative to the ["official" Gitleaks action](https://github.com/marketplace/actions/gitleaks), which doesn't offer as many configuration options.

Configuring the Action with `fail: true` ensures that the workflow stops if secrets are found in code. This happens before actually building the application.

For repositories with **GitHub Advanced Security** there's also the option to publish the SARIF report generated by the Gitleaks scanner.

#### Custom rules in TOML

The recommended GitHub Action already has [Cred Scan rules](https://github.com/jessehouwing/gitleaks-azure/blob/main/UDMSecretChecksv8.toml) baked into it, so it doesn't need additional configuration in order to work. However, while the default ruleset is able to catch the most common secret types, it might be beneficial to create custom rules as well. As an example, a simple Azure Storage Connection String detection would look like this:

```toml
[[rules]]
id = "azure-storage-cs-custom"
description = "Azure Storage Connection String"
regex = '''DefaultEndpointsProtocol=http[s]?;AccountName=(.+);AccountKey=(.+)==;'''
```

But the team does not have to write its own custom rule. Instead, they can use the ready-to-go rule provided in the Hints section and create their own .toml config.

## Move secrets to Azure Key Vault

Follow this guide: [https://docs.microsoft.com/en-us/azure/app-service/app-service-key-vault-references](https://docs.microsoft.com/en-us/azure/app-service/app-service-key-vault-references)

## Remove secrets from the source code

1. Remove secrets from the IaC source code
1. Update IaC deploy workflow
   1. Query Key Vault using `azure/get-keyvault-secrets` action
   1. Pass secret as a parameter
      - Bicep: `sqlServerAdminPassword`
      - Terraform: `mssql_server_administrator_login_password`

## (optional) Secret rotation

Secret rotation is automated using [Automate the rotation of a secret for resources that use one set of authentication credentials](https://docs.microsoft.com/en-us/azure/key-vault/secrets/tutorial-rotation) which covers exactly our case of automated SQL Server password change.

Full solution is provided in the `support/sqlsecretrotation` folder and it expects to find a Key Vault in the main resource group and SQL-PASSWORD secret with specific metadata (tags).

> The required secret tags are:
>
> - `CredentialId` - SQL admin username
> - `ProviderAddress` - resource ID of the SQL Database instance
> - `ValidityPeriodDays` - for how long should the secret stay valid

Teams can create it manually in the portal, but in the spirit of DevOps, they should modify the IaC code and include the Key Vault and secret population there. To make things smoother the Key Vault provisioning code is already present in `iac/bicep` and `iac/terraform` files.

For testing, it's a good idea to enable your account in Key Vault access policies, to be able to see secrets:

```bash
az keyvault set-policy --upn <username of the user> --name <keyvault name> --secret-permissions set delete get list
```

Individual App Services need to be modified to:

1. Have a managed identity
1. Add this identity to Key Vault access policies
1. Load secrets automatically from Key Vault, using references in application settings

These changes are by default commented out in the Bicep/Terraform IaC definitions.

Correctly configured Key Vault references should have a green tick "✔️ Key vault Reference" in the Web App's settings.
